{"ast":null,"code":"import { mergeMap } from 'rxjs/operators';\nimport { environment } from 'src/environments/environment';\nimport { CallbackOauth2Component } from '../../callback-oauth2/callback-oauth2.component';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"src/app/comun/callback-oauth2/oauth2.service\";\nconst ENDPOINT_SEC = environment.API_URL_SEC;\nexport let AuthInterceptor = /*#__PURE__*/(() => {\n  class AuthInterceptor {\n    constructor(oauth2) {\n      this.oauth2 = oauth2;\n    }\n    intercept(request, next) {\n      /**\n       * Se agrega token a los servicios excepto el de seguridad\n       */\n      if (environment.seguridad && !request.url.includes(ENDPOINT_SEC)) {\n        let refreshToken = localStorage.getItem(\"refreshToken\");\n        /**\n         * Cuando el token de acceso ha expirado y tienen token de refresco intenta renovar el token de acceso\n         */\n        if (refreshToken && this.isTokenExpired()) {\n          /**\n           * Invocación al servicio para renovar token\n           */\n          return this.oauth2.getNewToken(refreshToken).pipe(mergeMap(token => {\n            /**\n            * Cuando se tiene respuesta del servicio de renovación de token\n            * se guarda el nuevo token de acceso y refresco en localstorage\n            */\n            if (token) {\n              CallbackOauth2Component.setStorageToken(token.access_token, token.refresh_token, token.expires_in);\n            }\n            /**\n            * Cuando no hay resultado al tratar de renovar se colocan valores invalidos\n            */else {\n              CallbackOauth2Component.setStorageToken(\"invalidated\", \"invalidated\", 0);\n            }\n            return next.handle(this.addAccessToken(request));\n          }));\n        }\n        /**\n         * Si no hay token de refresco o no ha expirado el token de acceso agrega el token de acceso que ya se tiene\n         */else {\n          return next.handle(this.addAccessToken(request));\n        }\n      }\n      /**\n       * Retorna la petición sin modificación\n       */else {\n        let authReq = request;\n        return next.handle(authReq);\n      }\n    }\n    /**\n     * Valida si emisión del token ha expirado con una holgura de 30 segundos\n     */\n    isTokenExpired() {\n      let expiresIn = localStorage.getItem(\"expiresIn\");\n      let dateTimeToken = localStorage.getItem(\"dateTimeToken\");\n      if (dateTimeToken && expiresIn) {\n        let dateTimeTokenInt = parseInt(dateTimeToken);\n        let setDate = new Date(dateTimeTokenInt);\n        let expires = parseInt(expiresIn);\n        return Date.now() - setDate.getTime() > expires * 1000 - 30 * 1000;\n      }\n      return true;\n    }\n    /**\n     * Agrega el token de acceso al header de autorizacion\n     */\n    addAccessToken(request) {\n      let authToken = localStorage.getItem(\"accessToken\");\n      let newRequest = request;\n      if (authToken) {\n        return newRequest.clone({\n          headers: newRequest.headers.append('Authorization', 'Bearer ' + authToken)\n        });\n      }\n      return newRequest;\n    }\n    static {\n      this.ɵfac = function AuthInterceptor_Factory(t) {\n        return new (t || AuthInterceptor)(i0.ɵɵinject(i1.Oauth2Service));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: AuthInterceptor,\n        factory: AuthInterceptor.ɵfac\n      });\n    }\n  }\n  return AuthInterceptor;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}